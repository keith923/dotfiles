[{"diskText":"-- ┌────────────────────────────────────────────────────┐\n-- │ Sarzak Virtual Machine                             │\n-- ├────────────────────────────────────────────────────┤\n-- │ Keith Star (keith@uberfoo.com)                     │\n-- │ uberFoo, LLC                                       │\n-- ├────────────────────────────────────────────────────┤\n-- │ Copyright © 2015 uberFoo, LLC (http://uberfoo.com) │\n-- │ All rights reserved.                               │\n-- └────────────────────────────────────────────────────┘\n--\nmodule Metamodel\n    ( SarzakData\n    , SarzakType\n    , Key\n    , SarzakValue\n    ) where\n\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString.UTF8 as BU\n\n-- |This is the lowest level of the Metamodel.  Simply Data, which is in fact\n-- just bytes, and that we represent as a ByteString.\ntype SarzakData = B.ByteString\n\ndata SarzakType = Z_str\n                | Z_int\n                | Z_float\n                | Z_bool\n                | Z_nil deriving (Show)\n\ninstance Eq SarzakType where\n    Z_str == Z_str = True\n    Z_int == Z_int = True\n    Z_float == Z_float = True\n    Z_bool == Z_bool = True\n    Z_nil == Z_nil = True\n    _ == _ = False\n\n\nValue_Z_str = \n\n\n-- class Adaptor f where\n    -- adapt :: (a -> b) -> f a -> f b\n\n-- class Value v where\n\n\n-- instance Adaptor SarzakType where\n--     adapt Z_str =\n\ntype Key = String\ndata SarzakValue = Value { z_data :: SarzakData\n                         , z_type :: SarzakType\n                         }\n\ninstance Show SarzakValue where show = showValue\nshowValue :: SarzakValue -> String\nshowValue val\n    | z_type val == Z_str = \"\\\"\" ++ (BU.toString $ z_data val) ++ \"\\\"\"\n    | otherwise = \"dunno\"\n","text":"-- ┌────────────────────────────────────────────────────┐\n-- │ Sarzak Virtual Machine                             │\n-- ├────────────────────────────────────────────────────┤\n-- │ Keith Star (keith@uberfoo.com)                     │\n-- │ uberFoo, LLC                                       │\n-- ├────────────────────────────────────────────────────┤\n-- │ Copyright © 2015 uberFoo, LLC (http://uberfoo.com) │\n-- │ All rights reserved.                               │\n-- └────────────────────────────────────────────────────┘\n--\nmodule Metamodel\n    ( SarzakData\n    , SarzakType\n    , Key\n    , SarzakValue\n    ) where\n\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString.UTF8 as BU\n\n-- |This is the lowest level of the Metamodel.  Simply Data, which is in fact\n-- just bytes, and that we represent as a ByteString.\ntype SarzakData = B.ByteString\n\ndata SarzakType = Z_str\n                | Z_int\n                | Z_float\n                | Z_bool\n                | Z_nil deriving (Show)\n\ninstance Eq SarzakType where\n    Z_str == Z_str = True\n    Z_int == Z_int = True\n    Z_float == Z_float = True\n    Z_bool == Z_bool = True\n    Z_nil == Z_nil = True\n    _ == _ = False\n\n\nValue_Z_str = \n\n\n-- class Adaptor f where\n    -- adapt :: (a -> b) -> f a -> f b\n\n-- class Value v where\n\n\n-- instance Adaptor SarzakType where\n--     adapt Z_str =\n\ntype Key = String\ndata SarzakValue = Value { z_data :: SarzakData\n                         , z_type :: SarzakType\n                         }\n\ninstance Show SarzakValue where show = showValue\nshowValue :: SarzakValue -> String\nshowValue val\n    | z_type val == Z_str = \"\\\"\" ++ (BU.toString $ z_data val) ++ \"\\\"\"\n    | otherwise = \"dunno\"\n","active":false,"path":"/Users/uberfoo/Documents/projects/haskell/tmp/Metamodel.hs","scroll":22.375,"cursor":{"row":40,"column":14}},{"diskText":"import Control.Monad.State\n\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n\tRed == Red = True\n\tGreen == Green = True\n\tYellow == Yellow = True\n\t_ == _ = False\n\ninstance Show TrafficLight where\n\tshow Red = \"Red Light\"\n\tshow Green = \"Green Light\"\n\tshow Yellow = \"Yellow Light\"\n\nclass YesNo a where\n\tyesno :: a -> Bool\n\ninstance YesNo Int where\n\tyesno 0 = False\n\tyesno _ = True\n\ninstance YesNo [a] where\n\tyesno [] = False\n\tyesno _ = True\n\ninstance YesNo Bool where\n\tyesno = id\n\ninstance YesNo (Maybe a) where\n\tyesno Nothing = False\n\tyesno (Just _) = True\n\ndata CMaybe a = CNothing | CJust Int a deriving (Show)\ninstance Functor CMaybe where\n\tfmap f CNothing = CNothing\n\tfmap f (CJust i x) = CJust (i+1) (f x)\n\ntype Stack = [Int]\n\npop :: State Stack Int\n-- pop = State $ \\(x:xs) -> (x, xs)\npop = do\n\tx:xs <- get\n\tput xs\n\treturn x\n\npush :: Int -> State Stack ()\n-- push a = State $ \\xs -> ((), a:xs)\npush a = do\n\txs <- get\n\tput (a:xs)\n\treturn ()\n\npop1 = runState pop [1..5]\npush1 = runState (push 1) [2..5]\n\nstackManip :: State Stack Int\nstackManip = do\n\tpush 3\n\ta <- pop\n\tpop\n\nstackManip1 = runState stackManip [5, 8, 2, 1]\nstackManip2 = runState stackManip [1, 2, 3, 4]\n\nstackStuff :: State Stack ()\nstackStuff = do\n\ta <- pop\n\tif a == 5\n\t\tthen push a\n\t\telse do\n\t\t\tpush 3\n\t\t\tpush 8\n\nstackStuff1 = runState stackStuff [9, 0, 2, 1, 0]\nstackStuff2 = runState stackStuff [5, 4, 3, 2, 1]\n\nmoreStack :: State Stack ()\nmoreStack = do\n\ta <- stackManip\n\tif a == 100\n\t\tthen stackStuff\n\t\telse return ()\n\nmoreStack1 = runState moreStack [100, 9, 0, 2, 1, 0]\nmoreStack2 = runState moreStack [9, 0, 2, 1, 0]\n\nstackyStack :: State Stack ()\nstackyStack = do\n\tstackNow <- get\n\tif stackNow == [1, 2, 3]\n\t\tthen put [8, 3, 1]\n\t\telse put [9, 2, 1]\n\nstackyStack1 = runState stackyStack [1, 2, 3]\nstackyStack2 = runState stackyStack [10, 20, 30, 40]\n","text":"import Control.Monad.State\n\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n\tRed == Red = True\n\tGreen == Green = True\n\tYellow == Yellow = True\n\t_ == _ = False\n\ninstance Show TrafficLight where\n\tshow Red = \"Red Light\"\n\tshow Green = \"Green Light\"\n\tshow Yellow = \"Yellow Light\"\n\nclass YesNo a where\n\tyesno :: a -> Bool\n\ninstance YesNo Int where\n\tyesno 0 = False\n\tyesno _ = True\n\ninstance YesNo [a] where\n\tyesno [] = False\n\tyesno _ = True\n\ninstance YesNo Bool where\n\tyesno = id\n\ninstance YesNo (Maybe a) where\n\tyesno Nothing = False\n\tyesno (Just _) = True\n\ndata CMaybe a = CNothing | CJust Int a deriving (Show)\ninstance Functor CMaybe where\n\tfmap f CNothing = CNothing\n\tfmap f (CJust i x) = CJust (i+1) (f x)\n\ntype Stack = [Int]\n\npop :: State Stack Int\n-- pop = State $ \\(x:xs) -> (x, xs)\npop = do\n\tx:xs <- get\n\tput xs\n\treturn x\n\npush :: Int -> State Stack ()\n-- push a = State $ \\xs -> ((), a:xs)\npush a = do\n\txs <- get\n\tput (a:xs)\n\treturn ()\n\npop1 = runState pop [1..5]\npush1 = runState (push 1) [2..5]\n\nstackManip :: State Stack Int\nstackManip = do\n\tpush 3\n\ta <- pop\n\tpop\n\nstackManip1 = runState stackManip [5, 8, 2, 1]\nstackManip2 = runState stackManip [1, 2, 3, 4]\n\nstackStuff :: State Stack ()\nstackStuff = do\n\ta <- pop\n\tif a == 5\n\t\tthen push a\n\t\telse do\n\t\t\tpush 3\n\t\t\tpush 8\n\nstackStuff1 = runState stackStuff [9, 0, 2, 1, 0]\nstackStuff2 = runState stackStuff [5, 4, 3, 2, 1]\n\nmoreStack :: State Stack ()\nmoreStack = do\n\ta <- stackManip\n\tif a == 100\n\t\tthen stackStuff\n\t\telse return ()\n\nmoreStack1 = runState moreStack [100, 9, 0, 2, 1, 0]\nmoreStack2 = runState moreStack [9, 0, 2, 1, 0]\n\nstackyStack :: State Stack ()\nstackyStack = do\n\tstackNow <- get\n\tif stackNow == [1, 2, 3]\n\t\tthen put [8, 3, 1]\n\t\telse put [9, 2, 1]\n\nstackyStack1 = runState stackyStack [1, 2, 3]\nstackyStack2 = runState stackyStack [10, 20, 30, 40]\n","active":false,"path":"/Users/uberfoo/Documents/projects/haskell/tmp/foo.hs","scroll":2.25,"cursor":{"row":10,"column":25}},{"diskText":"data Expr = I Int\n          | B Bool\n          | Add Expr Expr\n          | Mul Expr Expr\n          | Eq Expr Expr\n\ninstance Show Expr where show = showExpr\n\nshowExpr :: Expr -> String\nshowExpr (I x) = show x\nshowExpr (B b) = show b\nshowExpr (Add a b) = \"(\" ++ show a ++ \" + \" ++ show b ++ \")\"\nshowExpr (Mul a b) = \"(\" ++ show a ++ \" * \" ++ show b ++ \")\"\nshowExpr (Eq a b) = show a ++ \" == \" ++ show b\n\neval :: Expr -> Maybe (Either Int Bool)\neval (I n) = Just $ Left n\neval (B b) = Just $ Right b\neval (Add e1 e2) = fmap (+) (eval e1) + (eval e2)\n-- eval (Mul e1 e2) = eval e1 * eval e2\n-- eval Nothing = Nothing\n","text":"data Expr = I Int\n          | B Bool\n          | Add Expr Expr\n          | Mul Expr Expr\n          | Eq Expr Expr\n\ninstance Show Expr where show = showExpr\n\nshowExpr :: Expr -> String\nshowExpr (I x) = show x\nshowExpr (B b) = show b\nshowExpr (Add a b) = \"(\" ++ show a ++ \" + \" ++ show b ++ \")\"\nshowExpr (Mul a b) = \"(\" ++ show a ++ \" * \" ++ show b ++ \")\"\nshowExpr (Eq a b) = show a ++ \" == \" ++ show b\n\neval :: Expr -> Maybe (Either Int Bool)\neval (I n) = Just $ Left n\neval (B b) = Just $ Right b\neval (Add e1 e2) = fmap (+) (eval e1) + (eval e2)\n-- eval (Mul e1 e2) = eval e1 * eval e2\n-- eval Nothing = Nothing\n","active":false,"path":"/Users/uberfoo/Documents/projects/haskell/tmp/dsl.hs","scroll":2.25,"cursor":{"row":18,"column":49}},{"diskText":"\"*\":\n  editor:\n    fontFamily: \"SourceCodePro-Light\"\n    fontSize: 13\n    showInvisibles: true\n    showIndentGuide: true\n    autoIndent: false\n    autoIndentOnPaste: false\n    tabLength: 4\n    softWrap: true\n    softTabs: false\n    softWrapAtPreferredLineLength: true\n    invisibles: {}\n  \"exception-reporting\":\n    userId: \"cee58b2b-c162-287d-f0ea-91f8c84cf66e\"\n  welcome:\n    showOnStartup: false\n  metrics:\n    userId: \"0dccf79fbf434e5fb3cd1d4f98ded47a1f237bf6\"\n  core:\n    disabledPackages: [\n      \"autocomplete-plus\"\n      \"haskell-ghc-mod\"\n    ]\n    themes: [\n      \"seti-ui\"\n      \"seti-syntax\"\n    ]\n  \"incremental-search\":\n    keepOptionsAfterSearch: false\n  \"github-issues\":\n    username: \"uberFoo\"\n  \"save-session\":\n    project: \"/Users/uberfoo/Documents/projects/haskell/tmp\"\n    windowX: 29\n    windowY: 413\n    windowWidth: 976\n    windowHeight: 775\n    dataSaveFolder: \"/Users/uberfoo/Documents/projects/dotfiles/atom/packages/save-session/projects\"\n    fullScreen: false\n  linter:\n    showErrorInline: true\n  \"ide-haskell\": {}\n  \"haskell-ghc-mod\": {}\n","text":"\"*\":\n  editor:\n    fontFamily: \"SourceCodePro-Light\"\n    fontSize: 13\n    showInvisibles: true\n    showIndentGuide: true\n    autoIndent: false\n    autoIndentOnPaste: false\n    tabLength: 4\n    softWrap: true\n    softTabs: false\n    softWrapAtPreferredLineLength: true\n    invisibles: {}\n  \"exception-reporting\":\n    userId: \"cee58b2b-c162-287d-f0ea-91f8c84cf66e\"\n  welcome:\n    showOnStartup: false\n  metrics:\n    userId: \"0dccf79fbf434e5fb3cd1d4f98ded47a1f237bf6\"\n  core:\n    disabledPackages: [\n      \"autocomplete-plus\"\n      \"haskell-ghc-mod\"\n    ]\n    themes: [\n      \"seti-ui\"\n      \"seti-syntax\"\n    ]\n  \"incremental-search\":\n    keepOptionsAfterSearch: false\n  \"github-issues\":\n    username: \"uberFoo\"\n  \"save-session\":\n    project: \"/Users/uberfoo/Documents/projects/haskell/tmp\"\n    windowX: 29\n    windowY: 413\n    windowWidth: 976\n    windowHeight: 775\n    dataSaveFolder: \"/Users/uberfoo/Documents/projects/dotfiles/atom/packages/save-session/projects\"\n    fullScreen: false\n  linter:\n    showErrorInline: true\n  \"ide-haskell\":\n    \n  \"haskell-ghc-mod\": {}\n","active":false,"path":"/Users/uberfoo/Documents/projects/dotfiles/atom/config.cson","scroll":7.067708333333334,"cursor":{"row":43,"column":4}}]