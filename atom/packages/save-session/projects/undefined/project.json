[{"diskText":"-- ┌────────────────────────────────────────────────────┐\n-- │ Sarzak Virtual Machine                             │\n-- ├────────────────────────────────────────────────────┤\n-- │ Keith Star (keith@uberfoo.com)                     │\n-- │ uberFoo, LLC                                       │\n-- ├────────────────────────────────────────────────────┤\n-- │ Copyright © 2015 uberFoo, LLC (http://uberfoo.com) │\n-- │ All rights reserved.                               │\n-- └────────────────────────────────────────────────────┘\n--\nmodule Metamodel\n    ( SarzakData\n    , SarzakType\n    , Key\n    , SarzakValue\n    ) where\n\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString.UTF8 as BU\n\n-- |This is the lowest level of the Metamodel.  Simply Data, which is in fact\n-- just bytes, and that we represent as a ByteString.\ntype SarzakData = B.ByteString\n\ndata SarzakType = Z_str\n                | Z_int\n                | Z_float\n                | Z_bool\n                | Z_nil deriving (Show)\n\ninstance Eq SarzakType where\n    Z_str == Z_str = True\n    Z_int == Z_int = True\n    Z_float == Z_float = True\n    Z_bool == Z_bool = True\n    Z_nil == Z_nil = True\n    _ == _ = False\n\n-- class Adaptor f where\n    -- adapt :: (a -> b) -> f a -> f b\n\n-- class Value v where\n\n\n-- instance Adaptor SarzakType where\n--     adapt Z_str =\n\ntype Key = String\ndata SarzakValue = Value { z_data :: SarzakData\n                         , z_type :: SarzakType\n                         }\n\ninstance Show SarzakValue where show = showValue\nshowValue :: SarzakValue -> String\nshowValue val\n    | z_type val == Z_str = \"\\\"\" ++ (BU.toString $ z_data val) ++ \"\\\"\"\n    | otherwise = \"dunno\"\n","text":"-- ┌────────────────────────────────────────────────────┐\n-- │ Sarzak Virtual Machine                             │\n-- ├────────────────────────────────────────────────────┤\n-- │ Keith Star (keith@uberfoo.com)                     │\n-- │ uberFoo, LLC                                       │\n-- ├────────────────────────────────────────────────────┤\n-- │ Copyright © 2015 uberFoo, LLC (http://uberfoo.com) │\n-- │ All rights reserved.                               │\n-- └────────────────────────────────────────────────────┘\n--\nmodule Metamodel\n    ( SarzakData\n    , SarzakType\n    , Key\n    , SarzakValue\n    ) where\n\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString.UTF8 as BU\n\n-- |This is the lowest level of the Metamodel.  Simply Data, which is in fact\n-- just bytes, and that we represent as a ByteString.\ntype SarzakData = B.ByteString\n\ndata SarzakType = Z_str\n                | Z_int\n                | Z_float\n                | Z_bool\n                | Z_nil deriving (Show)\n\ninstance Eq SarzakType where\n    Z_str == Z_str = True\n    Z_int == Z_int = True\n    Z_float == Z_float = True\n    Z_bool == Z_bool = True\n    Z_nil == Z_nil = True\n    _ == _ = False\n\n\nValue_Z_str =\n    \n\n-- class Adaptor f where\n    -- adapt :: (a -> b) -> f a -> f b\n\n-- class Value v where\n\n\n-- instance Adaptor SarzakType where\n--     adapt Z_str =\n\ntype Key = String\ndata SarzakValue = Value { z_data :: SarzakData\n                         , z_type :: SarzakType\n                         }\n\ninstance Show SarzakValue where show = showValue\nshowValue :: SarzakValue -> String\nshowValue val\n    | z_type val == Z_str = \"\\\"\" ++ (BU.toString $ z_data val) ++ \"\\\"\"\n    | otherwise = \"dunno\"\n","active":false,"path":"/Users/uberfoo/Documents/projects/haskell/tmp/Metamodel.hs","scroll":6.625,"cursor":{"row":62,"column":0}}]